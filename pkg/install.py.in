#!/usr/bin/env python3

import collections
import json
import logging
import os
import shutil
import subprocess

INSTALL_CMD = os.getenv("INSTALL") or "/usr/bin/install"
CP_CMD = os.getenv("CP") or "/usr/bin/cp"
LN_CMD = os.getenv("LN") or "/usr/bin/ln"

ManifestEntry = collections.namedtuple("ManifestEntry",
                                       ['entry_type', 'dest', 'src', 'mode', 'user', 'group'])

# Possible values for entry_type
# These must be kept in sync with the declarations in private/build_*.py
ENTRY_IS_FILE = 0  # Entry is a file: take content from <src>
ENTRY_IS_LINK = 1  # Entry is a symlink: dest -> <src>
ENTRY_IS_DIR = 2  # Entry is an empty dir
ENTRY_IS_TREE = 3  # Entry is a tree artifact: take tree from <src>


class NativeInstaller(object):
    def __init__(self, default_user=None, default_group=None, destdir=None):
        self.default_user = default_user
        self.default_group = default_group
        self.destdir = destdir
        self.entries = []

    def _chown_chmod(self, dest, mode, user, group):
        if mode:
            logging.info("CHMOD %s %s", mode, dest)
        if user or group:
            logging.info("CHOWN %s:%s %s", user, group, dest)

    def _do_file_copy(self, src, dest, mode, user, group):
        real_dest = os.path.join(self.destdir, dest)
        logging.info("COPY %s <- %s", real_dest, src)
        shutil.copyfile(src, real_dest)

    def _do_mkdir(self, dirname, mode, user, group):
        logging.info("MKDIR %s %s", mode, dirname)
        os.makedirs(dirname, int(mode, 8), exist_ok=True)

    def _do_symlink(self, target, link_name, mode, user, group):
        pass

    def _maybe_make_unowned_dir(self, path):
        logging.info("MKDIR (unowned) %s", path)
        os.makedirs(path, 0o755, exist_ok=True)
        if self.default_user or self.default_group:
            logging.info("CHOWN %s:%s %s",
                         self.default_user or "",
                         self.default_group or "",
                         path)

    def _install_file(self, entry):
        real_dest = os.path.join(self.destdir, entry.dest)
        self._maybe_make_unowned_dir(os.path.dirname(real_dest))
        self._do_file_copy(entry.src, real_dest, entry.mode, entry.user, entry.group)
        self._chown_chmod(real_dest, entry.mode, entry.user, entry.group)

    def _install_directory(self, entry):
        real_dest = os.path.join(self.destdir, entry.dest)
        self._maybe_make_unowned_dir(real_dest)
        self._do_mkdir(real_dest, entry.mode, entry.user, entry.group)
        self._chown_chmod(real_dest, entry.mode, entry.user, entry.group)

    def _install_treeartifact(self, entry):
        logging.info("COPYTREE %s <- %s/**", entry.dest, entry.src)
        raise NotImplementedError("treeartifact installation not yet supported")
        for root, dirs, files in os.walk(entry.src):
            relative_installdir = os.path.join(entry.dest, root)
            for d in dirs:
                self._maybe_make_unowned_dir(os.path.join(relative_installdir, d))

            logging.info("COPY_FROM_TREE %s <- %s", entry.dest, entry.src)
            logging.info("CHMOD %s %s", entry.mode, entry.dest)
            logging.info("CHOWN %s:%s %s", entry.user, entry.group, entry.dest)

    def _install_symlink(self, entry):
        logging.info("SYMLINK %s <- %s", entry.dest, entry.link_to)
        logging.info("CHMOD %s %s", entry.dest, entry.mode)
        logging.info("CHOWN %s.%s %s", entry.dest, entry.user, entry.group)
        raise NotImplementedError("symlinking not yet supported")

    def include_manifest_path(self, path):
        with open(path, 'r') as fh:
            self.include_manifest(fh)

    def include_manifest(self, manifest_fh):
        manifest_entries = json.load(manifest_fh)

        for entry in manifest_entries:
            self.entries.append(ManifestEntry(*entry))
        print(len(self.entries))

    def do_the_thing(self):
        for entry in self.entries:
            if entry.entry_type == ENTRY_IS_FILE:
                self._install_file(entry)
            elif entry.entry_type == ENTRY_IS_LINK:
                self._install_symlink(entry)
            elif entry.entry_type == ENTRY_IS_DIR:
                self._install_directory(entry)
            elif entry.entry_type == ENTRY_IS_TREE:
                self._install_treeartifact(entry)
            else:
                logging.error("Invalid entry type %d", entry.entry_type)
                pass

logging.getLogger().setLevel(logging.INFO)

destdir = os.getenv("DESTDIR") or None
installer = NativeInstaller(destdir=destdir)

subprocess.call(["find", "."])

for f in ["##MANIFEST_INCLUSION##"]:
    installer.include_manifest_path(f)

installer.do_the_thing()
